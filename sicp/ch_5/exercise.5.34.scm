#!/usr/bin/env csi -s

(use test)

;;; Exercise 5.34

;; Compile the iterative factorial procedure
;;
;;      (define (factorial n)
;;        (define (iter product counter)
;;          (if (> counter n)
;;              product
;;              (iter (* counter product)
;;                    (+ counter 1))))
;;        (iter 1 1))
;;
;; Annotate the resulting code, showing the essential difference
;; between the code for iterative and recursive versions of
;; `factorial' that makes one process build up stack space and the
;; other run in constant stack space.
;;
;; *Figure 5.17:* Compilation of the definition of the `factorial'
;; procedure
;;
;;      ;; construct the procedure and skip over code for the procedure body
;;        (assign val
;;                (op make-compiled-procedure) (label entry2) (reg env))
;;        (goto (label after-lambda1))
;;
;;      entry2     ; calls to `factorial' will enter here
;;        (assign env (op compiled-procedure-env) (reg proc))
;;        (assign env
;;                (op extend-environment) (const (n)) (reg argl) (reg env))
;;      ;; begin actual procedure body
;;        (save continue)
;;        (save env)
;;
;;      ;; compute `(= n 1)'
;;        (assign proc (op lookup-variable-value) (const =) (reg env))
;;        (assign val (const 1))
;;        (assign argl (op list) (reg val))
;;        (assign val (op lookup-variable-value) (const n) (reg env))
;;        (assign argl (op cons) (reg val) (reg argl))
;;        (test (op primitive-procedure?) (reg proc))
;;        (branch (label primitive-branch17))
;;      compiled-branch16
;;        (assign continue (label after-call15))
;;        (assign val (op compiled-procedure-entry) (reg proc))
;;        (goto (reg val))
;;      primitive-branch17
;;        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
;;
;;      after-call15   ; `val' now contains result of `(= n 1)'
;;        (restore env)
;;        (restore continue)
;;        (test (op false?) (reg val))
;;        (branch (label false-branch4))
;;      true-branch5  ; return 1
;;        (assign val (const 1))
;;        (goto (reg continue))
;;
;;      false-branch4
;;      ;; compute and return `(* (factorial (- n 1)) n)'
;;        (assign proc (op lookup-variable-value) (const *) (reg env))
;;        (save continue)
;;        (save proc)   ; save `*' procedure
;;        (assign val (op lookup-variable-value) (const n) (reg env))
;;        (assign argl (op list) (reg val))
;;        (save argl)   ; save partial argument list for `*'
;;
;;      ;; compute `(factorial (- n 1))', which is the other argument for `*'
;;        (assign proc
;;                (op lookup-variable-value) (const factorial) (reg env))
;;        (save proc)  ; save `factorial' procedure
;;
;;      ;; compute `(- n 1)', which is the argument for `factorial'
;;        (assign proc (op lookup-variable-value) (const -) (reg env))
;;        (assign val (const 1))
;;        (assign argl (op list) (reg val))
;;        (assign val (op lookup-variable-value) (const n) (reg env))
;;        (assign argl (op cons) (reg val) (reg argl))
;;        (test (op primitive-procedure?) (reg proc))
;;        (branch (label primitive-branch8))
;;      compiled-branch7
;;        (assign continue (label after-call6))
;;        (assign val (op compiled-procedure-entry) (reg proc))
;;        (goto (reg val))
;;      primitive-branch8
;;        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
;;
;;      after-call6   ; `val' now contains result of `(- n 1)'
;;        (assign argl (op list) (reg val))
;;        (restore proc) ; restore `factorial'
;;      ;; apply `factorial'
;;        (test (op primitive-procedure?) (reg proc))
;;        (branch (label primitive-branch11))
;;      compiled-branch10
;;        (assign continue (label after-call9))
;;        (assign val (op compiled-procedure-entry) (reg proc))
;;        (goto (reg val))
;;      primitive-branch11
;;        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
;;
;;      after-call9      ; `val' now contains result of `(factorial (- n 1))'
;;        (restore argl) ; restore partial argument list for `*'
;;        (assign argl (op cons) (reg val) (reg argl))
;;        (restore proc) ; restore `*'
;;        (restore continue)
;;      ;; apply `*' and return its value
;;        (test (op primitive-procedure?) (reg proc))
;;        (branch (label primitive-branch14))
;;      compiled-branch13
;;      ;; note that a compound procedure here is called tail-recursively
;;        (assign val (op compiled-procedure-entry) (reg proc))
;;        (goto (reg val))
;;      primitive-branch14
;;        (assign val (op apply-primitive-procedure) (reg proc) (reg argl))
;;        (goto (reg continue))
;;      after-call12
;;      after-if3
;;      after-lambda1
;;      ;; assign the procedure to the variable `factorial'
;;        (perform
;;         (op define-variable!) (const factorial) (reg val) (reg env))
;;        (assign val (const ok))
