
(require 'testes)
(import testes)
(require 'myutils)
(import myutils)

;;; Exercise 3.11

;; In section *Note 3-2-3:: we saw how the
;; environment model described the behavior of procedures with local
;; state.  Now we have seen how internal definitions work.  A typical
;; message-passing procedure contains both of these aspects.
;; Consider the bank account procedure of section *Note 3-1-1:::
;;
;;      (define (make-account balance)
;;        (define (withdraw amount)
;;          (if (>= balance amount)
;;              (begin (set! balance (- balance amount))
;;                     balance)
;;              "Insufficient funds"))
;;        (define (deposit amount)
;;          (set! balance (+ balance amount))
;;          balance)
;;        (define (dispatch m)
;;          (cond ((eq? m 'withdraw) withdraw)
;;                ((eq? m 'deposit) deposit)
;;                (else (error "Unknown request -- MAKE-ACCOUNT"
;;                             m))))
;;        dispatch)
;;
;; Show the environment structure generated by the sequence of
;; interactions
;;
;;      (define acc (make-account 50))
;;
;;      ((acc 'deposit) 40)
;;      90
;;
;;      ((acc 'withdraw) 60)
;;      30

;; A: see exercise.3.11.pdf / graffle

;; Where is the local state for `acc' kept?  Suppose we define another
;; account
;;
;;      (define acc2 (make-account 100))
;;
;; How are the local states for the two accounts kept distinct?
;; Which parts of the environment structure are shared between `acc'
;; and `acc2'?

;; A: calling make-account a second time would create E5, which would
;; contain the balance slot for acc2. The only part shared between acc
;; and acc2 is the global env, which contains make-account, acc, and
;; acc2.

;; (assert-equal x y)
(done)
